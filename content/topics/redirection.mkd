Redirection
===========

Description
-----------

One of the precepts of the [Unix Philosophy][philosophy] is that programs should
do one thing, and they should do it well. This is a fairly simple but powerful
idea, because smaller things are easier to build, and being to assemble simple
things into more complex structures is more flexible then having big
unchangeable blocks of functionality.

[philosophy]: http://en.wikipedia.org/wiki/Unix_philosophy "Wikipedia - Unix Philosophy"

Now of course, we've seen how these small programs work alone, which is all fine
and dandy. However, we need some way to start assembling these small programs,
otherwise we might as well be using legos with the connectors sanded off. This
is where redirection and pipes come in.


About File Descriptors
----------------------

Before we get any farther, we need to talk about how programs interact with the
rest of the system. When a program wants to interact with another program or a
file, it has to do this by requesting access to the resource through the
operating system The operating system acts as an intermediary between different
programs and the hardware, so that if a program does something dangerous or
experiences an error, only that program will be affected and the rest of the
system should remain unaffected.

When a program wants to open a file, it doesn't directly access the file but
instead gets a [file descriptor][fd]. A file descriptor is just a number as far
as the program is concerned, but the number essentially 'describes' a file,
hence the name 'file descriptor'.  When we want to read from this file, we would
do something like "read one line of input from the file associated with file
descriptor 5". This indirect method of working with files may seem odd, but in
fact it's very powerful.

[fd]: http://en.wikipedia.org/wiki/File_descriptor "Wikipedia - File Descriptor"

So now that we more or less know how files open programs, now we can start
talking about how we actually interact with programs. The neat thing is that
programs handle input and output in the same exact manner that they would with
files. That means that when you type some input into a terminal, the program
treats it as it is reading a file, and when the program wants to return
information to you, it acts like it is writing to a file.

By default, any program automatically gets three file descriptors. The first
one, standard in, with the file descriptor '0', is how you send the program
input. When you type something, the program reads that in from the file
descriptor 0. 

When the program wants to return information to you, it has two ways to output
things. The first one, standard out, is associated with file descriptor 1. If
the program has some sort of expected output, it will write it to standard
output. If an error occurs, there exists one more file descriptor, standard
error, with file descriptor 2. If something goes wrong, the program can write
the information to that file descriptor.

By default, standard out and standard error both go to your display. This may
seem redundant to have two, but we'll explain how this works later.

This is a picture of how the entire thing works.

    +----------------+                              +---------+
    | keyboard input |----- standard input (0) ---->| program |
    +----------------+                              +---------+
                                                       |   |
     +-------------+                                   |   |
     | the display |                                   |   |
     +-------------+                                   |   |
        ^       ^                                      |   |
        |       |                                      |   |
        |       +----------- standard output (1) ------+   |
        |                                                  |
        +------------------- standard error (2) -----------+

- - -

Writing output to a file
--------------------------

The reason that we treat normal input and output from a program as a file is
that we can actually *redirect* the normal input or output with a file! Say you
had some program generate some sort of information you wanted to store for
later. Instead of copying and pasting from your terminal, you could do it
directly. For example:

    % facter uptime uptime_days uptime_hours uptime_seconds
    uptime => 3 days
    uptime_days => 3
    uptime_hours => 91
    uptime_seconds => 327656

We could write the following to a file by using the '>' operator

    % facter uptime uptime_days uptime_hours uptime_seconds 1> facter.output

This introduces the output redirection operator. When you want to redirect some
output, you can add `#> file` to the end of the command, where # is either 1 or
2, depending on if you're redirecting standard out or standard error.

By default, '>' will overwrite any existing file, so if you did `facter 1>
facter.output` several times, each time it ran the old file would be removed
and the new output would replace it. If you want to add content to the end of
the file instead, you can use '#>>' to append output to the file instead of
wiping the file.

This is the model of things if you redirected standard out.

    +----------------+                              +---------+
    | keyboard input |----- standard input (0) ---->| program |
    +----------------+                              +---------+
                                                       |   |
     +-------------+        +---------+                |   |
     | the display |   +--->| a file! |                |   |
     +-------------+   |    +---------+                |   |
        ^              |                               |   |
        |              |                               |   |
        |              +---- standard output (1) ------+   |
        |                                                  |
        +------------------- standard error (2) -----------+

Reading input from a file
-------------------------

            +--------+                              +---------+
            |a file! |----- standard input (0) ---->| program |
            +--------+                              +---------+
                                                       |   |
     +-------------+                                   |   |
     | the display |                                   |   |
     +-------------+                                   |   |
        ^       ^                                      |   |
        |       |                                      |   |
        |       +----------- standard output (1) ------+   |
        |                                                  |
        +------------------- standard error (2) -----------+

Piping information across commands
----------------------------------

 - Text as the lingua franca of unix
